#!/usr/bin/perl -w
#modified from select_DMR_Jacobsen_method_v0.3.4.pl
# v0.0
#Differentially methylated regions (DMRs) were defined by tiling the genome into 100 base pair
#bins and comparing the number of called Cs and Ts in mutant and wild-type.
#Bins with absolute methylation difference of 0.4, 0.2, 0.1 for CG, CHG, CHH, respectively,
#and Benjamini-Hochberg corrected FDR < 0.01 (FisherÕs exact test) were selected.
#To avoid 100 bp bins with few cytosines, we selected for bins with at least 4 cytosines
#that are each covered by at least 4 reads in the wild-type replicate.
#This whole process was performed against three wild-type replicates, and only regions
#called significant in all three comparisons were defined to be DMRs.
#Finally, because loss and gain of methylation occurred in clusters,
#DMRs within 200 bp of each other were merged.
#All heatmaps in this study were generated by complete linkage
#and by using Euclidean distance as a distance measure.
#Rows with missing values were omitted for presentation purposes
#but did not affect the conclusions in the paper.
#Venn diagrams of DMRs were generated by calculating the overlap
#between 100 base pair tiles of mutant DMRs (i.e., without merging).

#Differentially methylated regions (DMRs) were defined by tiling the genome into 100 base pair($size_bin = 100)
#bins and comparing the number of called Cs and Ts in mutant and wild-type.
#Bins with absolute methylation difference of 0.4, 0.2, 0.1 for CG, CHG, CHH, respectively, ($CX_diff_cutoff)
#and Benjamini-Hochberg corrected FDR < 0.01 (FisherÕs exact test, $FDR_cutoff)  were selected.
#To avoid 100 bp bins with few cytosines, we selected for bins with at least 4 cytosines ($C_number_cutoff)
#that are each covered by at least 4 reads($large_depth_cutoff) in the wild-type replicate.
#This whole process was performed against three wild-type replicates, and only regions
#called significant in all three comparisons were defined to be DMRs.
#Finally, because loss and gain of methylation occurred in clusters,
#DMRs within 200 bp of each other were merged.
#All heatmaps in this study were generated by complete linkage
#and by using Euclidean distance as a distance measure.
#Rows with missing values were omitted for presentation purposes
#but did not affect the conclusions in the paper.
#Venn diagrams of DMRs were generated by calculating the overlap
#between 100 base pair tiles of mutant DMRs (i.e., without merging).

use strict;
use File::Spec;
use Text::NSP::Measures::2D::Fisher2::twotailed;

my $debug 	= 0;
if($debug){
	print STDERR "debug = 1\n\n";
}
my $bin_size     = 100;
my $sliding_size = 100;
#my $const = 4000000;
#my $allowed_gap  = 100;
#my $covered_num = int ($bin_size / $sliding_size);
#my ( $CG_diff_cutoff,  $CHG_diff_cutoff,  $CHH_diff_cutoff ) = (0.4, 0.2, 0.1);

my %diff_h = (  "CG"	=>	0.4,
		"CHG"	=>	0.2,
		"CHH"	=>	0.1
		);

my $FDR_cutoff = 0.01;
my $CXX_number_cutoff = 4;
my $large_depth_cutoff = 4;
my $small_depth_cutoff = 4;
die if( $small_depth_cutoff >  $large_depth_cutoff);

#my %chr_len = ("chr1"=>30427671, "chr2"=>19698289, "chr3"=>23459830, "chr4"=>18585056, "chr5"=>26975502);
my %chr_len = (
	       "1"=>30427671, "2"=>19698289, "3"=>23459830, "4"=>18585056, "5"=>26975502,
	       "Mt" => 366924, "Pt" => 154478
	       );
#my $R_script = "/Users/tang58/Kai_BS/myown/select_DMR_Jacobsen_method/p_adjust_BH_v0.3.R";
#die unless (-e $R_script);


my %bin_last_index;
# bin start from 0
for my $chr (sort keys %chr_len){
	my $len = $chr_len{$chr};
	#my $last = int( ($len - 1) / $sliding_size);
	my $last = int( ($len - 1) / $sliding_size );
	$bin_last_index{$chr} = $last;
}
if($debug){
	foreach my $chr (sort keys %bin_last_index){
		print STDERR join("\t", ($chr, $bin_last_index{$chr})), "\n";
	}
	print STDERR "\n\n";
	#exit;
}

my $usage = "$0 \n <WT_isMeth> <wt_label> <mut_isMeth> <mut_label> <outdir> <outpre>\n\n";
die $usage unless (@ARGV == 6);

my $wt_in  = shift or die;
my $wt_label = shift or die;

my $mut_in = shift or die;
my $mut_label = shift or die;

my $outdir = shift or die;
my $outpre = shift or die;
#my $label  = shift or die;
die unless (-d $outdir);
die $wt_in  unless (-e $wt_in);
die $mut_in unless (-e $mut_in);


if ($debug){
	$wt_in =  "/Volumes/My_Book/20120427_ShangHai_data/src/method5/debug/C24_WT_isMeth_chrC_error_separately_called_10000.txt";
	$mut_in = "/Volumes/My_Book/20120427_ShangHai_data/src/method5/debug/1-5_isMeth_chrC_error_separately_called_10000.txt";
 #	$output = "detail_debug_output.txt"; 
	#$bin_size = 50;
	#$sliding_size = 50;
#	%chr_len = ("chr1"=> 58344);
#	%bin_last_index = ('chr1' => int( ($chr_len{'chr1'} - 1) / $sliding_size));
	%chr_len = ("1"=> 58344);
	%bin_last_index = ('1' => int( ($chr_len{'1'} - 1) / $sliding_size));
}

my @types = ("CG", "CHG", "CHH");

foreach my $type(@types){
	my $raw_p_value_file = File::Spec->catfile($outdir, $outpre. "_" . $type . "_JacobsenCell_Bin" . $bin_size . "_FDR". $FDR_cutoff . "_sDep". $small_depth_cutoff. "_lDep". $large_depth_cutoff . "_Cnum" . $CXX_number_cutoff . "_raw_p_value.txt" );
	my $FDR_file = File::Spec->catfile($outdir, $outpre. "_" . $type . "_JacobsenCell_Bin" . $bin_size . "_FDR". $FDR_cutoff . "_sDep". $small_depth_cutoff. "_lDep". $large_depth_cutoff . "_Cnum" . $CXX_number_cutoff . "_FDR.txt" );

	my $out_hyper_list = File::Spec->catfile($outdir, $outpre. $type . "_hyper_JacobsenCell_Bin". $bin_size . "_FDR". $FDR_cutoff . "_sDep". $small_depth_cutoff. "_lDep". $large_depth_cutoff . "_Cnum" . $CXX_number_cutoff . ".txt" );
	my $out_hypo_list   = File::Spec->catfile($outdir, $outpre. $type . "_hypo_JacobsenCell_Bin" . $bin_size . "_FDR". $FDR_cutoff . "_sDep". $small_depth_cutoff. "_lDep". $large_depth_cutoff . "_Cnum" . $CXX_number_cutoff . ".txt" );

	die if (-e $raw_p_value_file);
	die if (-e $FDR_file);
	die if (-e $out_hyper_list);
	die if (-e $out_hypo_list);
}

#output line format
# coordinate	N	lDep_mut	lDep_wt	lDep_both	mut_div	mut_per(0.xxxx)	wt_div	wt_per(0.xxxx)	diff_m_minus_w
#1:1-100

foreach my $type(@types){
	my $raw_p_value_file = File::Spec->catfile($outdir, $outpre. "_" . $type . "_JacobsenCell_Bin" . $bin_size . "_FDR". $FDR_cutoff . "_sDep". $small_depth_cutoff. "_lDep". $large_depth_cutoff . "_Cnum" . $CXX_number_cutoff . "_raw_p_value.txt" );
	my $FDR_file = File::Spec->catfile($outdir, $outpre. "_" . $type . "_JacobsenCell_Bin" . $bin_size . "_FDR". $FDR_cutoff . "_sDep". $small_depth_cutoff. "_lDep". $large_depth_cutoff . "_Cnum" . $CXX_number_cutoff . "_FDR.txt" );

	my $out_hyper_list = File::Spec->catfile($outdir, $outpre.  "_" .$type . "_hyper_JacobsenCell_Bin". $bin_size . "_FDR". $FDR_cutoff . "_sDep". $small_depth_cutoff. "_lDep". $large_depth_cutoff . "_Cnum" . $CXX_number_cutoff . ".txt" );
	my $out_hypo_list   = File::Spec->catfile($outdir, $outpre. "_" . $type . "_hypo_JacobsenCell_Bin" . $bin_size . "_FDR". $FDR_cutoff . "_sDep". $small_depth_cutoff. "_lDep". $large_depth_cutoff . "_Cnum" . $CXX_number_cutoff . ".txt" );

	my @step1_list;
	my @step4_hyper_list;
	my @step4_hypo_list;
	
	my $diff = $diff_h{$type};
	
	print STDERR "type: ", $type, "\n";	
	#########
	#	step 1, filter by CX_diff 0.4, 0.2, 0.1 and Number_with_dep
	####################	
	step1_filter_by_meth_level ( $mut_in, $mut_label,  $wt_in, $wt_label,  $type,  \@step1_list , $diff  );

	#####
	#	step 2, cal raw fisher's exact test
	############
	
	step2_fisher_exact_test(\@step1_list, $raw_p_value_file, $mut_label, $wt_label, $type);
	step3_BH_correct($raw_p_value_file, $FDR_file);
	step4_filter_FDR( $FDR_file, \@step4_hyper_list, \@step4_hypo_list );
	step5_output($out_hyper_list, \@step4_hyper_list, $mut_label, $wt_label, $type );
	step5_output($out_hypo_list , \@step4_hypo_list,  $mut_label, $wt_label, $type );
	
	print STDERR "\n\n";
	
	#remove $raw_p_value_file
	`rm $raw_p_value_file`;
}

print STDERR "Done\n";


exit;

#check_output_exist();
#check_raw_p_value_file();
#check_FDR_file();


#step5_output($out_hyper_list, \@step4_hyper_list, $mut_label, $wt_label, $type );
# coordinate	N	lDep_mut	lDep_wt	lDep_both	mut_div	mut_per(0.xxxx)	wt_div	wt_per(0.xxxx)	diff_m_minus_w

sub step5_output{
	my ( $output, $ref, $mut_label_sub, $wt_label_sub, $type_sub ) = @_;
	die if(-e $output);
	
	open (OUT, ">>$output") or die;
	
	print OUT join( "\t", ( "coordinate", 	$type_sub. "_in_ref",  $type_sub. "_both",
			        $type_sub ."_" . $mut_label_sub , $type_sub ."_" . $wt_label_sub ,
				"div_" . $mut_label_sub, "level_" . $mut_label_sub,
				"div_" . $wt_label_sub,  "level_" . $wt_label_sub,
				$type_sub ."_diff_m_minus_w",  "raw_p", "FDR")), "\n";
	
	my $last_index = scalar(@{$ref}) - 1;
	
	for my $i(0..$last_index){
		print OUT $ref->[$i], "\n";
	}
	
#	print OUT $ref-> , "\n";
	
	close(OUT);
}

# all files should have header

#	step4_filter_FDR();
#print OUT join("\t", ( $cor, $lDep_both, $N_tmp, $sDep_mut_tmp, $sDep_wt_tmp, $div_mut, $per_mut, $div_wt, $per_wt, $diff , $p_val)), "\n";  fdr
			#0	1		2	3		4	5		6	7	8	9	10	      11
sub step4_filter_FDR{
	my ($file , $ref_hyper, $ref_hypo) = @_;
	die unless ( -e $file );
	open(IN, $file) or die;
	
	my $head = <IN>;
	while(<IN>){
		chomp;
		my @a = split "\t";
		my $fdr_val = $a[11];
		die $_ if( $fdr_val > 1);
		my $diff = $a[9];
		if(  $fdr_val <= $FDR_cutoff ){
			if( $diff > 0 ){# hyper
				push @{$ref_hyper}, $_;
			}elsif( $diff < 0 ){#hypo
				push @{$ref_hypo}, $_;
			}else{
				die "wrong diff: ", $_;
			}
		}
	}
	
	close(IN);
	print STDERR "step4_filter_FDR:\n";
	print STDERR "hyper: ", scalar(@{$ref_hyper}), "\n";
	print STDERR "hypo: ", scalar(@{$ref_hypo}), "\n";
}



#	step3_BH_correct ( $raw_p_value_file, $FDR_file );
sub step3_BH_correct{
	my ($raw_file, $fdr_file) = @_;
	
	
	die unless (-e $raw_file);
	die if (-e $fdr_file);
	my $R_script_sub = "/Users/tang58/Kai_BS/Jacobsen_Cell_method/p_FDR_BH_Jacobsen_Cell_method_v0.0.R";
	
	my $R_cmd = "R --slave --vanilla --args $raw_file $fdr_file < $R_script_sub ";

	print STDERR $R_cmd, "\n";
	`$R_cmd`;
	die unless (-e $fdr_file);
}

# step2_fisher_exact_test(\@step1_list, $raw_p_value_file);
#push @{$ref}, [$cor, $lDep_both, $N_tmp, $sDep_mut_tmp, $sDep_wt_tmp, $div_mut, $per_mut, $div_wt, $per_wt, $diff  ];

sub step2_fisher_exact_test{
	my ($ref, $file ,$mut_label_sub, $wt_label_sub, $type_sub ) = @_;
	die if(-e $file);
	open(OUT, ">>$file") or die;
	
	print OUT join( "\t", ( "coordinate",
			       $type_sub. "_in_ref",
			       $type_sub. "_both",
			       $type_sub ."_" . $mut_label_sub ,
			       $type_sub ."_" . $wt_label_sub ,
			       "div_" . $mut_label_sub,
			       "level_" . $mut_label_sub,
			       "div_" . $wt_label_sub,
			       "level_" . $wt_label_sub,
			       $type_sub ."_diff_m_minus_w",  "raw_p")), "\n";
	
	my @list_tmp = @{$ref};
	
	for my $i(0..$#list_tmp){
		my ( $cor,  $N_tmp,$lDep_both, $sDep_mut_tmp, $sDep_wt_tmp, $div_mut, $per_mut, $div_wt, $per_wt, $diff ) = @{$list_tmp[$i]};
		
		my ($mC_wt, $dep_wt)   = get_mC_dep( $div_wt );
		my ($mC_mut, $dep_mut) = get_mC_dep ( $div_mut ); 
		
		my $n11 = $mC_wt;
		my $n1p = $mC_wt + $mC_mut;
		my $np1 = $dep_wt;
		my $npp = $dep_wt + $dep_mut;
		my $p_val = 1;
		$p_val = cal_Fisher_exact_test($n11, $n1p, $np1, $npp);
		if($p_val eq "error"){
			#print STDERR join("\t", ($chr, $start, $end, $n11, $n1p, $np1, $npp)) , "\n\n" if($debug);
			$p_val = 1;
		}
		print OUT join("\t", ( $cor, $N_tmp, $lDep_both, $sDep_mut_tmp, $sDep_wt_tmp, $div_mut, $per_mut, $div_wt, $per_wt, $diff , $p_val)), "\n";
	}
	
	close OUT;	
}

sub get_mC_dep{
	my ($temp) = @_;
	if ($temp =~ /(\d+)\/(\d+)=/){
		return ($1, $2);
	}
	else{
		die $temp;
	}
}

# step1_filter_by_meth_level ( $mut_in, $mut_label,  $wt_in, $wt_label,  "CX",  \%step1_CX , $diff);

#output line format
# coordinate	N	lDep_mut	lDep_wt	lDep_both	mut_div	mut_per(0.xxxx)	wt_div	wt_per(0.xxxx)	diff_m_minus_w
#1:1-100
sub  step1_filter_by_meth_level{
	my ($mut_in_sub, $mut_label_sub,  $wt_in_sub, $wt_label_sub,  $type_sub,  $ref , $diff_sub) = @_;

	open (MUT, $mut_in_sub ) or die "cannot open $mut_in_sub: $!";
	open (WT,  $wt_in_sub )  or die "cannot open $wt_in_sub: $!" ;
	
	my $h_wt  = <WT>;
	my $h_mut = <MUT>;
# 0      1       2         3      4       5       6                7
#chr     pos     strand  type    num_C   depth   percentage      isMeth
#chr1    1       +       CHH      0       0       0	               0
# 0      1       2         3      4       5       6                7

	my %N; # record CXX number of reference in the bin {chr}->[index]
	my %N_sDep; # {chr}->{index}->{wt/mut} recored CXX number with depth >= small_cutoff, used for mthylation level 
	my %both_lDep ; #{chr}->[index]
	my (%dep_num, %mC_num);# ->{chr}->{index}->{wt/mut} 
#my $line = 0;
	my ($l_wt, $l_mut);
	while($l_wt = <WT>, $l_mut = <MUT>){
		chomp $l_wt;
		chomp $l_mut;
		my @a_wt  = split "\t", $l_wt;
		my @a_mut = split "\t", $l_mut;
		
		my $type = $a_wt[3];
		next unless ($type eq $type_sub);
	
		die unless ($a_wt[1] == $a_mut[1]);
		my $chr = simple_chr( $a_wt[0] );
		
		die unless (defined $chr_len{$chr});
		my $pos = $a_wt[1];
		
		my $dep_wt = $a_wt[5];
		my $dep_mut = $a_mut[5];
		
		my $mC_wt = $a_wt[4];
		my $mC_mut = $a_mut[4];
		
		my $index = int ( ( $pos - 1 ) / $bin_size );
		
		$N{$chr}->[$index] ++;
		
		if ( $dep_wt >=  $small_depth_cutoff ) {
			$N_sDep{$chr}->{$index} ->{wt} ++  ;
			$dep_num{$chr}->{$index}->{wt} += $dep_wt;
			$mC_num{$chr}->{$index} ->{wt} += $mC_wt;
		}
		if( $dep_mut >=  $small_depth_cutoff ){
			$N_sDep{$chr}->{$index} ->{mut} ++  ;
			$dep_num{$chr}->{$index}->{mut} += $dep_mut;
			$mC_num{$chr}->{$index} ->{mut} += $mC_mut;
		}
		if(  $dep_mut >= $large_depth_cutoff and  $dep_wt >=  $large_depth_cutoff){
			$both_lDep{$chr}->[$index] ++;
		}
	}
	
	close WT;
	close MUT;
	
	foreach my $chr(sort keys %chr_len){
		my $last = $bin_last_index{$chr};
		for (my $i = 0; $i < $bin_last_index{$chr}; $i++){
			
			next unless (defined $both_lDep{$chr}->[$i] );
			next unless ( $both_lDep{$chr}->[$i]  >= $CXX_number_cutoff );
			
			my ( $div_mut, $per_mut )   = cal_absolute_meth_level( $mC_num{$chr}->{$i}->{mut}, $dep_num{$chr}->{$i}->{mut});
			my (  $div_wt, $per_wt  )   = cal_absolute_meth_level( $mC_num{$chr}->{$i}->{wt},  $dep_num{$chr}->{$i}->{wt});
			my $diff = $per_mut - $per_wt;
			next unless ( abs($diff) >= $diff_sub);
			
			my $start = $i * $bin_size + 1;
			my $end   = $start + $bin_size - 1;
			
			my $cor = "$chr:$start-$end";
## coordinate	N	lDep_mut	lDep_wt	lDep_both	mut_div	mut_per(0.xxxx)	wt_div	wt_per(0.xxxx)	diff_m_minus_w
			my ($N_tmp, $lDep_both, $sDep_mut_tmp, $sDep_wt_tmp) = (0) x 4;
			$N_tmp		= $N{$chr}->[$i] 		;
			$sDep_mut_tmp	= $N_sDep{$chr}->{$i} ->{mut} 	;
			$sDep_wt_tmp	= $N_sDep{$chr}->{$i} ->{wt} 	;
			$lDep_both	= $both_lDep{$chr}->[$i] 	;
			push @{$ref}, [$cor, $N_tmp, $lDep_both, $sDep_mut_tmp, $sDep_wt_tmp,  $div_mut, $per_mut, $div_wt, $per_wt, $diff ];
		}
		my $i = $last;
		next unless (defined $both_lDep{$chr}->[$i] );
		next unless ( $both_lDep{$chr}->[$i]  >= $CXX_number_cutoff );
		my ( $div_mut, $per_mut )   = cal_absolute_meth_level( $mC_num{$chr}->{$i}->{mut}, $dep_num{$chr}->{$i}->{mut});
		my (  $div_wt, $per_wt  )   = cal_absolute_meth_level( $mC_num{$chr}->{$i}->{wt},  $dep_num{$chr}->{$i}->{wt});
		my $diff = $per_mut - $per_wt;
		next unless ( abs($diff) >= $diff_sub);
		
		my $start = $i * $bin_size + 1;
		my $end   = $chr_len{$chr};
			
		my $cor = "$chr:$start-$end";
## coordinate	N	lDep_mut	lDep_wt	lDep_both	mut_div	mut_per(0.xxxx)	wt_div	wt_per(0.xxxx)	diff_m_minus_w
		my ($N_tmp, $lDep_both, $sDep_mut_tmp, $sDep_wt_tmp) ;
		$N_tmp		= $N{$chr}->[$i] 	;
		$sDep_mut_tmp	= $N_sDep{$chr}->{$i} ->{mut} 	;
		$sDep_wt_tmp	= $N_sDep{$chr}->{$i} ->{wt} 	;
		$lDep_both	= $both_lDep{$chr}->[$i] 	;
		push @{$ref}, [$cor, $N_tmp, $lDep_both, $sDep_mut_tmp, $sDep_wt_tmp,  $div_mut, $per_mut, $div_wt, $per_wt, $diff  ];
	}
	
	print STDERR "step1_filter_by_meth_level_list_number: ", scalar(@{$ref}), "\n";
}
#print OUT join( "\t", (
#"coordinate",
#$type_sub. "_in_ref",
#$type_sub. "_both",

#$type_sub ."_" . $mut_label_sub ,
#$type_sub ."_" . $wt_label_sub ,

#"div_" . $mut_label_sub,
##"level_" . $mut_label_sub,

#"div_" . $wt_label_sub,
#"level_" . $wt_label_sub,
#$type_sub ."_diff_m_minus_w",
#"raw_p",
#"FDR")), "\n";

sub cal_absolute_meth_level{
	my ($mC, $dep) = @_;
	die if($dep == 0);
	my $per = sprintf("%.4f", $mC/$dep);
	return ( "$mC/$dep=", $per);
}

sub simple_chr{
	my ($chr) = @_;
	if( $chr =~ /chr/i){
		$chr =~  s/chr//i;
	}
	if($chr eq "M" ){
		$chr = "Mt";
	}elsif( $chr eq "C"){
		$chr = "Pt";
	}
	return $chr;
}

sub output_hyper_list{
	my ($file, $ref) = @_;
	die if(-e $file);
	
	open(OUT, ">>$file") or die;
	
#	print OUT join("\t", ( "chr", "start", "end", "DMC_num", "CG_num", "CHG_num", "CHH_num", 
#				"mut_CG", "mut_CG_per","mut_CHG", "mut_CHG_per","mut_CHH", "mut_CHH_per",
#				"wt_CG", "wt_CG_per",	"wt_CHG", "wt_CHG_per","wt_CHH", "wt_CHH_per", 
#				 "avge_meth_level_mut", "avge_meth_level_wt")), "\n";
				
	print OUT join("\t", ( "chr", "start", "end", "DMC_num", "DMC_type", "CG_num", "CHG_num", "CHH_num", 
				"mut_CG", "mut_CG_per","mut_CHG", "mut_CHG_per","mut_CHH", "mut_CHH_per",
				"wt_CG", "wt_CG_per",	"wt_CHG", "wt_CHG_per","wt_CHH", "wt_CHH_per", 
				 "avge_meth_level_mut", "avge_meth_level_wt")), "\n";
				
	my $last_index = scalar(@{$ref}) - 1;
	
	for my $i(0..$last_index){
		
		print OUT join("\t",  @{$ref->[$i]}), "\n";
	}
	
	close(OUT);	
}


sub output_hypo_list{
	my ($file, $ref) = @_;
	die if(-e $file);
	
	open(OUT, ">>$file") or die;
	
#	print OUT join("\t", ( "chr", "start", "end", "DMC_num", "CG_num", "CHG_num", "CHH_num", 
#							"wt_CG", "wt_CG_per",	"wt_CHG", "wt_CHG_per","wt_CHH", "wt_CHH_per",
#						   "mut_CG", "mut_CG_per","mut_CHG", "mut_CHG_per","mut_CHH", "mut_CHH_per",
#			  			   "avge_meth_level_wt"  , "avge_meth_level_mut")), "\n";
				
	print OUT join("\t", ( "chr", "start", "end", "DMC_num", "DMC_type", "CG_num", "CHG_num", "CHH_num", 
							"wt_CG", "wt_CG_per",	"wt_CHG", "wt_CHG_per","wt_CHH", "wt_CHH_per",
						   "mut_CG", "mut_CG_per","mut_CHG", "mut_CHG_per","mut_CHH", "mut_CHH_per",
			  			   "avge_meth_level_wt"  , "avge_meth_level_mut")), "\n";
				
	my $last_index = scalar(@{$ref}) - 1;
	
	for my $i(0..$last_index){
		
		print OUT join("\t",  @{$ref->[$i]}), "\n";
	}
	
	close(OUT);	
	
}


# adjust_list_border(\@list_hyper_merged, \@hyper_list_border, \%DMC, DMC_cutoff);
# record_region_pos(\@list, \%hash)
sub record_region_pos{
	my ($ref_list, $ref_h) = @_;
	my $last_index = scalar(@{$ref_list}) - 1;
	
	foreach my $i (0..$last_index){
	#	my ($chr, $start, $end, $num) = split "_", $ref_list->[$i];
		my @pts = split "_", $ref_list->[$i];
		my ($chr, $start, $end) = @pts[0..2];
		
		for my $j($start..$end){
			$ref_h->{$chr}->[$j] = $i;
		}
	}
}

sub round {
    my($number) = shift;
    #return int($number + .5);
    return int($number + .5 * ($number <=> 0)); # take care of negative numbers too
}

#		           WT	    mut
#		           word2   ~word2
#mC	     word1    n11      n12 | n1p
#No.T	~word1    n21      n22 | n2p
#      	          --------------
#		          np1      np2   npp

#$n11 = $wt_mC;
#$n1p = $wt_mC + $mut_mC;
#$np1 = $wt_depth;
#$npp = $wt_depth + $mut_depth;

sub cal_Fisher_exact_test{
	my($n11, $n1p ,$np1, $npp) = @_;
	my  $p_value = calculateStatistic( n11=>$n11,
					   n1p=>$n1p,
					   np1=>$np1,
					   npp=>$npp);
	my $errorCode;
	if( ($errorCode = getErrorCode())){
#		print STDERR $errorCode." - ".getErrorMessage(),"\n\n";
  		return "error";
	}
  	else{
		return $p_value;
	}
}

sub cal_mean{
	my ($ref) = @_;
	my $sum = 0;
	my $num = 0;
	
	foreach my $item (@{$ref}){
		$sum+=$item;
		$num++;
	}
	if($num == 0){
		return "NONE";
	}else{
		return ( sprintf ( "%.4f", 100 * $sum / $num));
	}
}
